// Code generated by modelgen. DO NOT EDIT

package models

import (
    "fmt"
    "strings"
    "database/sql"
	"context"
)


type UserQueryBuilder interface {
	WhereIDIs(int64) UserQueryBuilder
	WhereID(operator string, rhs int64) UserQueryBuilder

	// WhereIDGT(int64) UserQueryBuilder
	// WhereIDGE(int64) UserQueryBuilder
	// WhereIDLT(int64) UserQueryBuilder
	// WhereIDLE(int64) UserQueryBuilder

	WhereNameIs(string) UserQueryBuilder
	WhereName(operator string, rhs string) UserQueryBuilder

	OrderByAsc(column UserColumn) UserQueryBuilder
	OrderByDesc(column UserColumn) UserQueryBuilder

	Limit(int) UserQueryBuilder
	Offset(int) UserQueryBuilder

	getPlaceholder() string

	First(db *sql.DB) (User, error)
	Last(db *sql.DB) (User, error)

	SetID(int64) UserQueryBuilder

	SetName(string) UserQueryBuilder

	Add(ctx context.Context, record *User, db *sql.DB) error

	Update(db *sql.DB) (sql.Result, error)

	Delete(db *sql.DB) (sql.Result, error)

	Fetch(db *sql.DB) ([]User, error)
	FindAll(db *sql.DB) ([]User, error)

	SQL() (string, error)

	Debug() UserQueryBuilder
}

type _dont_use_user_query_builder struct {
	mode string

	where struct {
		ID struct {
			argument interface{}
			operator string
		}

		Name struct {
			argument interface{}
			operator string
		}
	}

	set struct {
		ID string

		Name string
	}

	orderBy []string
	groupBy string

	projected []string

	limit  int
	offset int

	whereArgs  []interface{}
	setArgs    []interface{}
	valuesArgs []any

	debugMode bool
}

func Users() UserQueryBuilder {
	return &_dont_use_user_query_builder{}
}

func (q *_dont_use_user_query_builder) SQL() (string, error) {
	if q.mode == "" {
		q.mode = "select"
	}

	var query string
	var err error
	if q.mode == "select" {
		query, err = q.sqlSelect()
	} else if q.mode == "update" {
		query, err = q.sqlUpdate()
	} else if q.mode == "delete" {
		query, err = q.sqlDelete()
	} else {
		return "", fmt.Errorf("unsupported query mode '%s'", q.mode)
	}

	if q.debugMode {
		fmt.Printf("Generating query: %s\n", query)
	}

	return query, err
}

type UserColumn string

var UserColumns = struct {
	ID   UserColumn
	Name UserColumn
}{
	ID:   UserColumn("id"),
	Name: UserColumn("name"),
}

func (q *_dont_use_user_query_builder) getPlaceholder() string {
	return "?"
}

func (q *_dont_use_user_query_builder) Limit(l int) UserQueryBuilder {
	q.mode = "select"
	q.limit = l
	return q
}

func (q *_dont_use_user_query_builder) Offset(l int) UserQueryBuilder {
	q.mode = "select"
	q.offset = l
	return q
}

func (q User) Values() []interface{} {
	var values []interface{}
	values = append(values, &q.ID)
	values = append(values, &q.Name)

	return values
}

func (q *_dont_use_user_query_builder) Debug() UserQueryBuilder {
	q.debugMode = true
	return q
}

func UsersFromRows(rows *sql.Rows) ([]User, error) {
	var Users []User
	for rows.Next() {
		var m User
		err := rows.Scan(

			&m.ID,

			&m.Name,
		)
		if err != nil {
			return nil, err
		}
		Users = append(Users, m)
	}
	return Users, nil
}

func UserFromRow(row *sql.Row) (User, error) {
	if row.Err() != nil {
		return User{}, row.Err()
	}
	var q User
	err := row.Scan(
		&q.ID,
		&q.Name,
	)
	if err != nil {
		return User{}, err
	}

	return q, nil
}

func (q *_dont_use_user_query_builder) Update(db *sql.DB) (sql.Result, error) {
	q.mode = "update"
	args := append(q.setArgs, q.whereArgs...)
	query, err := q.SQL()
	if err != nil {
		return nil, err
	}
	return db.Exec(query, args...)
}

func (q *_dont_use_user_query_builder) Delete(db *sql.DB) (sql.Result, error) {
	q.mode = "delete"
	query, err := q.SQL()
	if err != nil {
		return nil, err
	}
	return db.Exec(query, q.whereArgs...)
}

func (q *_dont_use_user_query_builder) Fetch(db *sql.DB) ([]User, error) {
	q.mode = "select"
	query, err := q.SQL()
	if err != nil {
		return nil, err
	}
	rows, err := db.Query(query, q.whereArgs...)
	if err != nil {
		return nil, err
	}
	return UsersFromRows(rows)
}

func (q *_dont_use_user_query_builder) FindAll(db *sql.DB) ([]User, error) {
	return q.Fetch(db)
}

func (q *_dont_use_user_query_builder) First(db *sql.DB) (User, error) {
	q.mode = "select"
	q.orderBy = []string{"ORDER BY id ASC"}
	q.Limit(1)
	query, err := q.SQL()
	if err != nil {
		return User{}, err
	}
	row := db.QueryRow(query, q.whereArgs...)
	if row.Err() != nil {
		return User{}, row.Err()
	}
	return UserFromRow(row)
}

func (q *_dont_use_user_query_builder) Last(db *sql.DB) (User, error) {
	q.mode = "select"
	q.orderBy = []string{"ORDER BY id DESC"}
	q.Limit(1)
	query, err := q.SQL()
	if err != nil {
		return User{}, err
	}
	row := db.QueryRow(query, q.whereArgs...)
	if row.Err() != nil {
		return User{}, row.Err()
	}
	return UserFromRow(row)
}

func (q *_dont_use_user_query_builder) OrderByAsc(column UserColumn) UserQueryBuilder {
	q.mode = "select"
	q.orderBy = append(q.orderBy, fmt.Sprintf("%s ASC", string(column)))
	return q
}

func (q *_dont_use_user_query_builder) OrderByDesc(column UserColumn) UserQueryBuilder {
	q.mode = "select"
	q.orderBy = append(q.orderBy, fmt.Sprintf("%s DESC", string(column)))
	return q
}

func (q *_dont_use_user_query_builder) sqlSelect() (string, error) {
	if q.projected == nil {
		q.projected = append(q.projected, "*")
	}
	base := fmt.Sprintf("SELECT %s FROM users", strings.Join(q.projected, ", "))

	var wheres []string

	if q.where.ID.operator != "" {
		wheres = append(wheres, fmt.Sprintf("%s %s %s", "id", q.where.ID.operator, fmt.Sprint(q.where.ID.argument)))
	}

	if q.where.Name.operator != "" {
		wheres = append(wheres, fmt.Sprintf("%s %s %s", "name", q.where.Name.operator, fmt.Sprint(q.where.Name.argument)))
	}

	if len(wheres) > 0 {
		base += " WHERE " + strings.Join(wheres, " AND ")
	}

	if len(q.orderBy) > 0 {
		base += fmt.Sprintf(" ORDER BY %s", strings.Join(q.orderBy, ", "))
	}

	if q.limit != 0 {
		base += " LIMIT " + fmt.Sprint(q.limit)
	}
	if q.offset != 0 {
		base += " OFFSET " + fmt.Sprint(q.offset)
	}
	return base, nil
}

func (q *_dont_use_user_query_builder) sqlUpdate() (string, error) {
	base := fmt.Sprintf("UPDATE users ")

	var wheres []string
	var sets []string

	if q.where.ID.operator != "" {
		wheres = append(wheres, fmt.Sprintf("%s %s %s", "id", q.where.ID.operator, fmt.Sprint(q.where.ID.argument)))
	}
	if q.set.ID != "" {
		sets = append(sets, fmt.Sprintf("%s = %s", "id", fmt.Sprint(q.set.ID)))
	}

	if q.where.Name.operator != "" {
		wheres = append(wheres, fmt.Sprintf("%s %s %s", "name", q.where.Name.operator, fmt.Sprint(q.where.Name.argument)))
	}
	if q.set.Name != "" {
		sets = append(sets, fmt.Sprintf("%s = %s", "name", fmt.Sprint(q.set.Name)))
	}

	if len(sets) > 0 {
		base += "SET " + strings.Join(sets, " , ")
	}

	if len(wheres) > 0 {
		base += " WHERE " + strings.Join(wheres, " AND ")
	}

	return base, nil
}

func (q *_dont_use_user_query_builder) sqlDelete() (string, error) {
	base := fmt.Sprintf("DELETE FROM users")

	var wheres []string

	if q.where.ID.operator != "" {
		wheres = append(wheres, fmt.Sprintf("%s %s %s", "id", q.where.ID.operator, fmt.Sprint(q.where.ID.argument)))
	}

	if q.where.Name.operator != "" {
		wheres = append(wheres, fmt.Sprintf("%s %s %s", "name", q.where.Name.operator, fmt.Sprint(q.where.Name.argument)))
	}

	if len(wheres) > 0 {
		base += " WHERE " + strings.Join(wheres, " AND ")
	}

	return base, nil
}

func (q *_dont_use_user_query_builder) WhereIDGE(ID int64) UserQueryBuilder {
	q.whereArgs = append(q.whereArgs, ID)
	q.where.ID.argument = q.getPlaceholder()
	q.where.ID.operator = ">="
	return q
}

func (q *_dont_use_user_query_builder) WhereIDGT(ID int64) UserQueryBuilder {
	q.whereArgs = append(q.whereArgs, ID)
	q.where.ID.argument = q.getPlaceholder()
	q.where.ID.operator = ">"
	return q
}

func (q *_dont_use_user_query_builder) WhereIDLE(ID int64) UserQueryBuilder {
	q.whereArgs = append(q.whereArgs, ID)
	q.where.ID.argument = q.getPlaceholder()
	q.where.ID.operator = "<="
	return q
}

func (q *_dont_use_user_query_builder) WhereIDLT(ID int64) UserQueryBuilder {
	q.whereArgs = append(q.whereArgs, ID)
	q.where.ID.argument = q.getPlaceholder()
	q.where.ID.operator = "<"
	return q
}

func (q *_dont_use_user_query_builder) WhereID(operator string, ID int64) UserQueryBuilder {
	q.whereArgs = append(q.whereArgs, ID)
	q.where.ID.argument = q.getPlaceholder()
	q.where.ID.operator = operator
	return q
}

func (q *_dont_use_user_query_builder) WhereIDIs(ID int64) UserQueryBuilder {
	q.whereArgs = append(q.whereArgs, ID)
	q.where.ID.argument = q.getPlaceholder()
	q.where.ID.operator = "="
	return q
}

func (q *_dont_use_user_query_builder) WhereName(operator string, Name string) UserQueryBuilder {
	q.whereArgs = append(q.whereArgs, Name)
	q.where.Name.argument = q.getPlaceholder()
	q.where.Name.operator = operator
	return q
}

func (q *_dont_use_user_query_builder) WhereNameIs(Name string) UserQueryBuilder {
	q.whereArgs = append(q.whereArgs, Name)
	q.where.Name.argument = q.getPlaceholder()
	q.where.Name.operator = "="
	return q
}

func (q *_dont_use_user_query_builder) SetID(ID int64) UserQueryBuilder {
	q.mode = "update"
	q.setArgs = append(q.setArgs, ID)
	q.set.ID = q.getPlaceholder()
	return q
}

func (q *_dont_use_user_query_builder) SetName(Name string) UserQueryBuilder {
	q.mode = "update"
	q.setArgs = append(q.setArgs, Name)
	q.set.Name = q.getPlaceholder()
	return q
}

func (q *_dont_use_user_query_builder) Add(ctx context.Context, record *User, db *sql.DB) error {
	query := "INSERT INTO users (id, name) VALUES (?, ?)"
	if q.debugMode {
		fmt.Printf("Generating query: %s\n", query)
	}
	res, err := db.ExecContext(ctx, query, record.ID, record.Name)
	if err != nil {
		return err
	}

	id, err := res.LastInsertId()
	if err != nil {
		return err
	}
	record.ID = id
	return nil
}
	