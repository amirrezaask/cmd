package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/iancoleman/strcase"
)

func main() {
	var file string
	flag.StringVar(&file, "file", ".", "path to the file to generate the httphandler for")
	flag.Parse()

	generateForFile(file)
}

const annotation = "@handlerfunc"

func generateForFile(filePath string) {
	inputFilePath, err := filepath.Abs(filePath)
	if err != nil {
		panic(err)
	}

	pathList := filepath.SplitList(inputFilePath)
	pathList = pathList[:len(pathList)-1]
	fileDir := filepath.Join(pathList...)
	fileSet := token.NewFileSet()
	fileAst, err := parser.ParseFile(fileSet, filePath, nil, parser.ParseComments)
	if err != nil {
		panic(err)
	}

	actualName := strings.TrimSuffix(filePath, filepath.Ext(filePath))
	outputFilePath := filepath.Join(fileDir, fmt.Sprintf("%s_handlerfunc_gen.go", actualName))
	outputFile, err := os.Create(outputFilePath)
	if err != nil {
		panic(err)
	}
	defer func(outputFile *os.File) {
		err := outputFile.Close()
		if err != nil {
			fmt.Println(err)
		}
	}(outputFile)

	empty := true
	var codes []string

	type templateData struct {
		Pkg         string
		IsMethod    bool
		RecvType    string
		Name        string
		BindingType string
	}
	for _, decl := range fileAst.Decls {
		funcDecl, ok := decl.(*ast.FuncDecl)
		if !ok {
			continue
		}

		ft := funcDecl.Type
		if ft.Params.NumFields() != 2 {
			fmt.Fprintf(os.Stderr, "given functions should have exactly 2 parameters not %d", ft.Params.NumFields())
			return
		}

		if ft.Results.NumFields() != 2 {
			fmt.Fprintf(os.Stderr, "given functions should have exactly 2 returns not %d", ft.Results.NumFields())
			return
		}
		if !strings.Contains(funcDecl.Doc.Text(), annotation) {
			continue
		}
		td := templateData{
			Pkg:         fileAst.Name.Name,
			IsMethod:    funcDecl.Recv != nil,
			Name:        funcDecl.Name.Name,
			BindingType: fmt.Sprint(funcDecl.Type.Params.List[1].Type),
		}

		if funcDecl.Recv != nil {
			t := funcDecl.Recv.List[0].Type
			switch t := t.(type) {
			case *ast.StarExpr:
				td.RecvType = "*" + t.X.(*ast.Ident).Name
			case *ast.Ident:
				td.RecvType = t.Name
			}
		}
		var buf bytes.Buffer
		err := tmpl.Execute(&buf,
			td,
		)
		if err != nil {
			panic(err)
		}

		codes = append(codes, buf.String())
		empty = false
	}

	if empty {
		os.Remove(outputFilePath)
		return
	}
	var outputText bytes.Buffer

	err = fileTemplate.Execute(&outputText, struct {
		Pkg  string
		Code string
	}{Pkg: fileAst.Name.Name, Code: strings.Join(codes, "\n\n")})
	if err != nil {
		panic(err)
	}

	var toWrite []byte

	bs, err := format.Source(outputText.Bytes())
	if err != nil {
		toWrite = outputText.Bytes()
	} else {
		toWrite = bs
	}
	outputFile.Write(toWrite)
}

var funcMap = template.FuncMap{
	"toSnakeCase": func(name string) string {
		return strcase.ToSnake(name)
	},
	"ToLowerCamelCase": func(name string) string {
		return strcase.ToLowerCamel(name)
	},
}

var fileTemplate = template.Must(template.New("handlerfuncgen").Funcs(funcMap).Parse(`
	// Code generated by httphandlergen. DO NOT EDIT
package {{ .Pkg }}

import (
    "fmt"
    "net/http"
	"encoding/json"
)


{{ .Code }}
	`))

var tmpl = template.Must(template.New("httphandlergen").Funcs(funcMap).Parse(
	`
	func {{if .IsMethod }} (r {{ .RecvType }}) {{ end }} {{ .Name }}HandlerFunc(w http.ResponseWriter, req *http.Request) {
		var requestBody {{ .BindingType }}
		err := json.NewDecoder(req.Body).Decode(&requestBody)
		if err != nil {
			panic(err)
		}


		resp, err := {{if .IsMethod }}r.{{ end}}{{.Name}}(req, requestBody)
		if err != nil {
			panic(err)
		}

		err = json.NewEncoder(w).Encode(resp)
		if err != nil {
			panic(err)
		}
	}
	`,
))
